%include  extendDict.it

%{
#include <ius.h>
#include "iusAcquisitionADT.h"
#include "iusHistoryNodeADT.h"
#include "iusPatternListADT.h"
#include "iusParameterDictADT.h"
#include "iusDemodulationDictADT.h"
%}


%typemap(in) int {
        if (PyFloat_Check($input)) {
            $1 = (int) PyFloat_AsDouble($input);
            printf("warning, casting float to n = %d\n", $1);
        }
        else {
            $1 = (int) PyInt_AsLong($input);
        }
}

%typemap(in) ius_t {
        $1 = (ius_t) $input;
}

%typemap(in) iup_t {
        $1 = (iup_t) $input;
}

%typemap(in) iut_t {
        $1 = (iut_t) $input;
}

%typemap(in) IusTransducerShape {
        if (PyFloat_Check($input)) {
            $1 = (int) PyFloat_AsDouble($input);
            printf("warning, casting float to n = %d\n", $1);
        }
        else {
            $1 = (int) PyInt_AsLong($input);
        }
}

%typemap(in) (float *apodization, int numElements) {
    int i;
    Py_ssize_t length;
    if (!PySequence_Check($input)) {
        PyErr_SetString(PyExc_ValueError,"Expected a sequence");
        return NULL;
    }
    length = PySequence_Length($input);
    float *temp = calloc(length, sizeof(float));
    printf("Got an array of length %d\n", (int)length);
    for (i = 0; i < length; i++) {
        PyObject *o = PySequence_GetItem($input,i);
        if (PyNumber_Check(o)) {
            temp[i] = (float) PyFloat_AsDouble(o);
            printf("Element %d = %f\n",i, temp[i]);
        } else {
            PyErr_SetString(PyExc_ValueError,"Sequence elements must be numbers");
        return NULL;
        }
    }
    printf("Additional memory allocated at: %p\n", (void*)temp);
    $1 = temp;
    $2 = (int)length;
}

%typemap(freearg) (float *apodization, int numElements) {
        printf("Additional memory freed from: %p\n", (void*)$1);
        free($1);
}


%include <ius2DNonParametricSource.h>
%include <ius2DParametricSource.h>
%include <ius2DSize.h>
%include <ius2DTransducer.h>
%include <ius2DTransducerElement.h>
%include <ius2DTransducerElementList.h>
%include <ius3DAngle.h>
%include <ius3DNonParametricSource.h>
%include <ius3DParametricSource.h>
%include <ius3DSize.h>
%include <ius3DTransducer.h>
%include <ius3DTransducerElement.h>
%include <ius3DTransducerElementList.h>
%include <iusBasicFunctions.h>
%include <iusData.h>
%include <iusDataStream.h>
%include <iusDemodulation.h>
%include <iusError.h>
%include <iusAcquisition.h>
%include <iusFile.h>
%include <iusFilter.h>
%include <iusFrame.h>
%include <iusFrameList.h>
%include <iusHDF5.h>
%include <iusHistoryNode.h>
%include <iusHistoryNodeList.h>
%include <iusInputFile.h>
%include <iusInputFileStructure.h>
%include <iusIqFile.h>
%include <iusIqFileStructure.h>
%include <iusNonParametricPulse.h>
%include <iusOffset.h>
%include <iusParametricPulse.h>
%include <iusPattern.h>
%include <iusPatternList.h>
%include <iusPatternListDict.h>
%include <iusIqPattern.h>
%include <iusIqPatternList.h>
%include <iusIqPatternListDict.h>
%include <iusPosition.h>
%include <iusPulse.h>
%include <iusPulseDict.h>
%include <iusReceiveChannelMap.h>
%include <iusReceiveChannelMapDict.h>
%include <iusReceiveSettings.h>
%include <iusReceiveSettingsDict.h>
%include <iusSource.h>
%include <iusSourceDict.h>
%include <iusTGC.h>
%include <iusTransducer.h>
%include <iusTransducerElement.h>
%include <iusTransmitApodization.h>
%include <iusTransmitApodizationDict.h>
%include <iusTypes.h>
%include <iusUtil.h>
%include <iusUuid.h>
%include <ius.h>

%include <iusError.h>


// Extend code for given Dict class and contained type
// The EXTEND_DICT_ADT macro assumes, the ADT implemention
// is stored in a separate file
// i.e. iusParameterDictADT.h for ParameterDict data type.
//
EXTEND_DICT_ADT(ParameterDict, char)
EXTEND_DICT_ADT(DemodulationDict, IusDemodulation)


%include <iusPatternListADT.h>

%extend IusPatternList {
        IusPatternList() {
            int numPatterns = 1;
            iursd_t receiveSettingsDict = NULL;
            iurcmd_t receiveChannelMapDict = NULL;
            return iusPatternListCreate(numPatterns, receiveSettingsDict, receiveChannelMapDict);
        }

        ~IusPatternList() {
            iusPatternListDelete($self);
        }

};

%include <iusHistoryNodeADT.h>
%extend IusHistoryNode {             // Attach these functions to struct Vector
        IusHistoryNode(char *nodeType) {
            return iusHistoryNodeCreate(nodeType);
        }

        ~IusHistoryNode() {
            iusHistoryNodeDelete($self);
        }

        char *Type()
        {
            return iusHistoryNodeGetType($self);
        }

        int NumParams()
        {
            return iusHistoryNodeGetNumParams($self);
        }

        int NumParents()
        {
            return iusHistoryNodeGetNumParents($self);
        }

        char *__str__() {
            static char temp[256];
            sprintf(temp, "IusHistoryNode [%s]\n", $self->pType);
            return &temp[0];
        }
};

%include <iusAcquisitionADT.h>

%extend IusAcquisition {             // Attach these functions to struct Vector
        IusAcquisition(float speedOfSound, int date, char *description) {
            return iusAcquisitionCreate(speedOfSound,date,description);
        }
        ~IusAcquisition() {
            iusAcquisitionDelete($self);
        }

        char *__str__() {
            static char temp[256];
            sprintf(temp, "IusAcquisition [%g, %d, %s]\n", $self->speedOfSound, $self->date, $self->pDescription);
            return &temp[0];
        }
};