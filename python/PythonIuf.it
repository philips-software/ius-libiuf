%{
#include <numpy/arrayobject.h>

#include <iuf.h>
#include <dataGenerators.h>
#include "iufAcquisitionADT.h"
#include "iufDataADT.h"
#include "iufInputFile.h"
#include "iufHistoryNodeADT.h"
#include "iufPatternListADT.h"
#include "iufPatternListDictADT.h"
#include "iufIqPatternListADT.h"
#include "iufIqPatternListDictADT.h"
#include "iufParameterDictADT.h"
#include "iufDemodulationDictADT.h"
#include "iufReceiveSettingsDictADT.h"
#include <iufReceiveChannelMapADT.h>
#include <iufReceiveChannelMapDictADT.h>
#include <iuf2DTransducerPrivate.h>
#include <iufTransducerADT.h>
#include <iuf2DTransducerADT.h>
#include <iuf3DTransducerADT.h>
#include <iufTransmitApodizationADT.h>
#include <iufTransmitApodizationDictADT.h>

%}


// Write to python's stdout, used to write to MatLab console
#define printf PySys_WriteStdout

// Allow for using a MatLab double as int.
%typemap(in) int {
        if (PyFloat_Check($input)) {
            $1 = (int) PyFloat_AsDouble($input);
            printf("warning, casting float to n = %d\n", $1);
        }
        else {
            $1 = (int) PyInt_AsLong($input);
        }
}

// Handle both iupp_t and iunpp_t as iup_t
typedef iup_t iupp_t;
typedef iup_t iunpp_t;

// Handle iu2dps_t, iu2dnps_t, iu3dps_t and iu3dnps_t as iuf_t
typedef ius_t iu2dps_t;
typedef ius_t iu2dnps_t;
typedef ius_t iu3dps_t;
typedef ius_t iu3dnps_t;
typedef iuhn_t iuif_t;
%ignore iu2dps_t;
%ignore iu2dnps_t;
%ignore iu3dps_t;
%ignore iu3dnps_t;
%ignore iuif_t;

// Handle both iu3Dt_t and iu2Dt_t as iut_t
%typemap(in) iut_t {
        if (!SWIG_IsOK(SWIG_ConvertPtr($input, (void **) &$1, $descriptor(iu2dt_t), 0)) &&
           (!SWIG_IsOK(SWIG_ConvertPtr($input, (void **) &$1, $descriptor(iu3dt_t), 0))))
        {
            SWIG_exception_fail(SWIG_TypeError, "in method '$symname', expecting type iu2dt_t or iu3dt_t");
        }
}

%typemap(in) float centerFrequency {
    if (PyFloat_Check($input)) {
        $1 = (float) PyFloat_AsDouble($input);
        printf("warning, casting float to n = %f\n", $1);
    }
}


%typemap(in) IufTransducerShape {
        if (PyFloat_Check($input)) {
            $1 = (int) PyFloat_AsDouble($input);
            printf("warning, casting float to n = %d\n", $1);
        }
        else {
            $1 = (int) PyInt_AsLong($input);
        }
}

// Handle an input array for transmitApodization
// Handle a double as an array of length 1
%typemap(in) (float *apodization, int numElements) {
    Py_ssize_t i;
    Py_ssize_t length;
    if (PySequence_Check($input)) {
        length = PySequence_Length($input);
    } else if (PyFloat_Check($input)) {
        length = (Py_ssize_t)1;
    } else {
        PyErr_SetString(PyExc_ValueError,"Expected a sequence or a float");
        return NULL;
    }
    float * temp = calloc(length, sizeof(float));
    printf("Got an array of length %d\n", (int)length);
    if( length == (Py_ssize_t)1 ) {
        temp[0] = (float)PyFloat_AsDouble($input);
        printf("Processing length %d\n", (int)length);
    } else {
        printf("Else found for array of length %d\n", (int)length);
        for (i = 0; i < length; i++) {
            PyObject *o = PySequence_GetItem($input,i);
            if (PyNumber_Check(o)) {
                temp[i] = (float)PyFloat_AsDouble(o);
                printf("Element %lld = %f\n",i,temp[i]);
            } else {
                PyErr_SetString(PyExc_ValueError,"Sequence elements must be numbers");
            }
        }
    }
    printf("Additional memory allocated at: %p\n", (void*)temp);
    $1 = temp;
    $2 = (int)length;
}

%typemap(freearg) (float *apodization, int numElements) {
        printf("Additional memory freed from: %p\n", (void*)$1);
        free($1);
}

// IMPORTANT NOTE:
//
//      Keep %include <iufError.h> before %exception
//
// Prevent the error stack from getting cleared by
// the invocation of the iufError routines themselves.
// (i.e. do not wrap exception handling code in
// error module for now).
//
%include <iufError.h>
%exception {
    iufErrorLogClear();
    $action
    if (iufErrorGetCount() > 0) {
        char *err = iufErrorString();
        PyErr_Format(PyExc_Exception,
        "Call %s failed: %s", \
        __func__, err
        );
        SWIG_fail;
    }
}

%include "numpy.i"

%init %{
import_array();
%}

%apply (double* IN_ARRAY1, int DIM1){(double* input, int length)};

int iufDataFill
        (
                iud_t data,
                double *input,
                int length
        );


%include <iuf2DNonParametricSource.h>
%include <iuf2DParametricSource.h>
%include <iuf2DSize.h>
%include <iuf2DTransducer.h>
%include <iuf2DTransducerPrivate.h>
%include <iuf2DTransducerElement.h>
%include <iuf2DTransducerElementList.h>
%include <iuf3DAngle.h>
%include <iuf3DNonParametricSource.h>
%include <iuf3DParametricSource.h>
%include <iuf3DSize.h>
%include <iuf3DTransducer.h>
%include <iuf3DTransducerElement.h>
%include <iuf3DTransducerElementList.h>
%include <iufBasicFunctions.h>
%include <iufData.h>
%include <iufDataStream.h>
%include <iufDemodulation.h>
%include <iufError.h>
%include <iufAcquisition.h>
%include <iufFile.h>
%include <iufFilter.h>
%include <iufFrame.h>
%include <iufFrameList.h>
%include <iufHDF5.h>
%include <iufHistoryNode.h>
%include <iufHistoryNodeList.h>
%include <iufInputFile.h>
%include <iufInputFileStructure.h>
%include <iufIqFile.h>
%include <iufIqFileStructure.h>
%include <iufIqPattern.h>
%include <iufIqPatternList.h>
%include <iufIqPatternListDict.h>
%include <iufIqPatternListADT.h>
%include <iufIqPatternListDictADT.h>
%include <iufNonParametricPulse.h>
%include <iufOffset.h>
%include <iufParametricPulse.h>
%include <iufPattern.h>
%include <iufPatternList.h>
%include <iufPatternListDict.h>
%include <iufPatternListADT.h>
%include <iufPatternListDictADT.h>
%include <iufPosition.h>
%include <iufPulse.h>
%include <iufPulseDict.h>
%include <iufReceiveChannelMap.h>
%include <iufReceiveChannelMapDict.h>
%include <iufReceiveChannelMapADT.h>
%include <iufReceiveChannelMapDictADT.h>
%include <iufReceiveSettingsDictADT.h>
%include <iufReceiveSettings.h>
%include <iufReceiveSettingsDict.h>
%include <iufSource.h>
%include <iufSourceDict.h>
%include <iufTGC.h>
%include <iufTransducer.h>
%include <iufTransducerElement.h>
%include <iufTransmitApodization.h>
%include <iufTransmitApodizationDict.h>
%include <iufTransmitApodizationADT.h>
%include <iufTransmitApodizationDictADT.h>
%include <iufTypes.h>
%include <iufUtil.h>
%include <iufUuid.h>
%include <iuf.h>

%include <iufError.h>


// Extend code for given Dict class and contained type
// The EXTEND_DICT_ADT macro assumes, the ADT implemention
// is stored in a separate file
// i.e. iufParameterDictADT.h for ParameterDict data type.
//
%include  extendDict.it
EXTEND_DICT_ADT(ParameterDict, char);
EXTEND_DICT_ADT(DemodulationDict, IufDemodulation);
EXTEND_DICT_ADT(ReceiveSettingsDict, IufReceiveSettings);
EXTEND_DICT_ADT(IqPatternListDict, IufIqPatternList)
EXTEND_DICT_ADT(PatternListDict, IufPatternList)
EXTEND_DICT_ADT(ReceiveChannelMapDict, IufReceiveChannelMap)
EXTEND_DICT_ADT(TransmitApodizationDict, IufTransmitApodization)

%include <iufTransducerADT.h>
%include <iuf2DTransducerADT.h>
//%include <iufPatternListADT.h>
//%include <iufIqPatternListADT.h>
%include <iufHistoryNodeADT.h>
%include <iufAcquisitionADT.h>
%include <dataGenerators.h>
%include <iufDataADT.h>
